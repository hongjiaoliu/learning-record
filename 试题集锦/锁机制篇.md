### 说说线程安全问题

1. 概述

线程安全问题其实就是并发的正确性问题，一个线程安全的行为，既不需要额外的同步和协调，也不用考虑在runtime中的调度和交替执行，一定能返回预期的结果

2. 五种线程安全场景

  + 不变性
  最简单最纯粹的场景就是不变性，一个不可变的对象一定是线程安全的，如final
  + 绝对线程安全
  绝对线程安全是不切实际的，即使是线程安全的Vector容器，也只是在方法中用了synchronized修饰，方法调用时还是需要额外同步，否则，在多线程同时remove，仍然会有Index边界溢出的错误
  + 相对线程安全
  一般意义上的线程安全就是相对线程安全，单独操作是线程安全的，但是在特定情况下，还需要在调用时增加额外的同步手段。Java提供的线程安全如Vector、HashTabe、Collections.synchronizedCollection()等，都是相对线程安全
  + 线程兼容
  一般意义上的不是线程安全其实是线程兼容，指的是本身并不线程安全，可以在调用时增加同步手段，实现线程安全，常见的ArrayList和HashMap都是线程安全的
  + 线程对立
  一些极端情况下，无论采用什么同步措施，都不能实现线程安全，就是线程对立，如Thread的suspend和resume，不能并行调用，很容易出现死锁

3. 实现方法

  + 互斥同步
    就是共享数据在并行运算中，同一时刻只能一个线程使用，synchronized和ReentrantLock都是互斥同步
  + 非阻塞同步
    其实就是互斥同步的对立面，非阻塞同步相对乐观，认为并行不一定导致共享数据冲突，如果真的出现争用冲突，再做补偿即可（如重试操作，比如compareAndSet(current,next)就是不断尝试赋值，如果current和next的值和预期不一致，就说明数据被修改了，会再次循环尝试），sum.misc.Unsafe类就是非阻塞同步机制（ClassLoader才能直接使用，用户只能通过Java API间接使用，如AtomicInteger），非阻塞同步依赖于硬件指令集的发展和支持
  + 无同步方案
    无同步方案不是不管线程安全，而是通过其他方式实现线程安全，不需要同步

### volatile 实现原理

1. 概述

  + 当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取

  + volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的，有两层语义：保证可见性、不保证原子性；禁止指令重排序
2. 原理  

  + Java代码： instance = new Singleton();//instance是volatile变量
汇编代码： 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);

  + 有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，lock前缀的指令在多核处理器下会引发了两件事情

### synchronize 实现原理

1. 概述
  + synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性
  + Java中每一个对象都可以作为锁
    + 普通同步方法，锁是当前实例对象
    + 静态同步方法，锁是当前类的class对象
    + 同步方法块，锁是括号里面的对象
2. 原理
  + 同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。

  + 同步代码块

    monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁

  + 同步方法

    synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象

### synchronized 与 lock 的区别

|对比项|synchronized|lock|
|---|---|---|
|存在层次|Java的关键字，在jvm层面上|是一个类|
|锁的释放|以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁|在finally中必须释放锁，不然容易造成线程死锁|
|锁的获取|假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待|分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待|
|锁状态|无法判断|可以判断|
|锁类型|可重入 不可中断 非公平|可重入 可判断 可公平（两者皆可）|
|性能|少量同步|大量同步|

### 悲观锁

1. 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

2. MySQL InnoDB中使用悲观锁，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

3. 适用场景

  比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量

### 乐观锁

1. 概念

  + 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

  + 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

2. 优缺点

  乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

3. 实现细节

  + 冲突检测
  + 数据更新

### 乐观锁的一种实现方式——CAS

1. 概念
  + CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

  + 乐观锁是一种思想。CAS是这种思想的一种实现方式

2. 三个操作数

  + 1. 内存位置（V）

  + 2. 预期原值（A）

  + 3. 新值(B)

  + 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的

3. 扩展 —— CAS与对象创建

  CAS还有一个应用，那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的。即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性

### ABA 问题
1.概念
  + CAS会导致“ABA问题

  + CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化

  + 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的

2. 解决方案

  部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少

### 乐观锁的业务场景及实现方式

1. 适用场景

  比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量

2. 实现方式

  + 使用版本标识来确定读到的数据与提交时的数据是否一致

    + 加上version字段，每一次的操作都会更新version，提交时如果version不匹配，停止本次提交，可以尝试下一次的提交，以保证拿到的是操作1提交后的结果
  + CAS
