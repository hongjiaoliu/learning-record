##5.1 Lock接口
1：Lock接口出现之前，Java主要靠synchronized关键字实现锁功能。它提供了显式地获取和释放锁的便捷性，但是也缺少了synchronized的隐式获取和释放锁的便捷性，程序员可以在不同场景进行选择。
Lock的使用也很简单，示例代码如下：

	Lock lock = new ReentrantLock();
	lock.lock();
	try {
	}finally{
		lock.unlock();
	}

不要将获取锁的代码也放到try块中，因为这样的话，如果在获取锁（**自定义锁的实现**）的过程中，出现了异常，会导致锁无故的释放。

2：Lock 接口提供的synchronized关键字不具备的主要特性

| 特性 | 描述 |
| ------------- |:-------------:|  
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁 | 与synchronized不同，获取到锁的线程可以响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁 | 在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回 |

3： Lock是一个接口，它定义的API方法如下：

 | 特性 | 描述 |
| ------------- |:-------------:|  
|void lock()|获取锁|
|void lockInterruptibly() throws InterruptedException|可中断地获取锁|
|boolean tryLock()|尝试非阻塞的获取锁，如果能够获取，返回true,反之为false|
|boolean tryLock(long time,TimeUnit unit)throws InterruptedException|超时获取锁|
|void unlock()|释放锁|
|Condition newCondition()|获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调动该组件的wait()方法，而调用后，当前线程将释放锁|
